# Generated from jsbach.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3%")
        buf.write("\u00b1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\3\2\7\2\"\n\2\f\2\16\2%\13\2")
        buf.write("\3\2\3\2\3\3\3\3\3\3\7\3,\n\3\f\3\16\3/\13\3\5\3\61\n")
        buf.write("\3\3\3\3\3\3\3\3\3\3\4\7\48\n\4\f\4\16\4;\13\4\3\5\3\5")
        buf.write("\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5F\n\5\3\6\3\6\3\6\3\6")
        buf.write("\3\7\3\7\3\7\3\b\3\b\3\b\7\bR\n\b\f\b\16\bU\13\b\3\t\3")
        buf.write("\t\3\t\3\n\3\n\3\n\7\n]\n\n\f\n\16\n`\13\n\3\13\3\13\3")
        buf.write("\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\5\13l\n\13\3\f")
        buf.write("\3\f\3\f\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3")
        buf.write("\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\5\17\u0087\n\17\3\20\3\20\3\20\3\20\3\20\3\20\3")
        buf.write("\20\3\20\7\20\u0091\n\20\f\20\16\20\u0094\13\20\5\20\u0096")
        buf.write("\n\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\5\20")
        buf.write("\u00a1\n\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3")
        buf.write("\20\7\20\u00ac\n\20\f\20\16\20\u00af\13\20\3\20\2\3\36")
        buf.write("\21\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36\2\b\3\2\21")
        buf.write("\22\3\2\23\24\3\2\25\26\3\2\37 \3\2\16\17\3\2\f\r\2\u00bd")
        buf.write("\2#\3\2\2\2\4(\3\2\2\2\69\3\2\2\2\bE\3\2\2\2\nG\3\2\2")
        buf.write("\2\fK\3\2\2\2\16N\3\2\2\2\20V\3\2\2\2\22Y\3\2\2\2\24a")
        buf.write("\3\2\2\2\26m\3\2\2\2\30s\3\2\2\2\32w\3\2\2\2\34\u0086")
        buf.write("\3\2\2\2\36\u00a0\3\2\2\2 \"\5\4\3\2! \3\2\2\2\"%\3\2")
        buf.write("\2\2#!\3\2\2\2#$\3\2\2\2$&\3\2\2\2%#\3\2\2\2&\'\7\2\2")
        buf.write("\3\'\3\3\2\2\2(\60\7#\2\2)-\7\37\2\2*,\7\37\2\2+*\3\2")
        buf.write("\2\2,/\3\2\2\2-+\3\2\2\2-.\3\2\2\2.\61\3\2\2\2/-\3\2\2")
        buf.write("\2\60)\3\2\2\2\60\61\3\2\2\2\61\62\3\2\2\2\62\63\7\35")
        buf.write("\2\2\63\64\5\6\4\2\64\65\7\36\2\2\65\5\3\2\2\2\668\5\b")
        buf.write("\5\2\67\66\3\2\2\28;\3\2\2\29\67\3\2\2\29:\3\2\2\2:\7")
        buf.write("\3\2\2\2;9\3\2\2\2<F\5\n\6\2=F\5\f\7\2>F\5\16\b\2?F\5")
        buf.write("\20\t\2@F\5\22\n\2AF\5\24\13\2BF\5\26\f\2CF\5\30\r\2D")
        buf.write("F\5\32\16\2E<\3\2\2\2E=\3\2\2\2E>\3\2\2\2E?\3\2\2\2E@")
        buf.write("\3\2\2\2EA\3\2\2\2EB\3\2\2\2EC\3\2\2\2ED\3\2\2\2F\t\3")
        buf.write("\2\2\2GH\7\37\2\2HI\7\3\2\2IJ\5\36\20\2J\13\3\2\2\2KL")
        buf.write("\7\4\2\2LM\7\37\2\2M\r\3\2\2\2NO\7\5\2\2OS\5\36\20\2P")
        buf.write("R\5\36\20\2QP\3\2\2\2RU\3\2\2\2SQ\3\2\2\2ST\3\2\2\2T\17")
        buf.write("\3\2\2\2US\3\2\2\2VW\7\6\2\2WX\5\36\20\2X\21\3\2\2\2Y")
        buf.write("Z\7#\2\2Z^\5\36\20\2[]\5\36\20\2\\[\3\2\2\2]`\3\2\2\2")
        buf.write("^\\\3\2\2\2^_\3\2\2\2_\23\3\2\2\2`^\3\2\2\2ab\7\7\2\2")
        buf.write("bc\5\34\17\2cd\7\35\2\2de\5\6\4\2ek\7\36\2\2fg\7\b\2\2")
        buf.write("gh\7\35\2\2hi\5\6\4\2ij\7\36\2\2jl\3\2\2\2kf\3\2\2\2k")
        buf.write("l\3\2\2\2l\25\3\2\2\2mn\7\t\2\2no\5\34\17\2op\7\35\2\2")
        buf.write("pq\5\6\4\2qr\7\36\2\2r\27\3\2\2\2st\7\37\2\2tu\7\n\2\2")
        buf.write("uv\5\36\20\2v\31\3\2\2\2wx\7\13\2\2xy\5\36\20\2y\33\3")
        buf.write("\2\2\2z{\5\36\20\2{|\t\2\2\2|}\5\36\20\2}\u0087\3\2\2")
        buf.write("\2~\177\5\36\20\2\177\u0080\t\3\2\2\u0080\u0081\5\36\20")
        buf.write("\2\u0081\u0087\3\2\2\2\u0082\u0083\5\36\20\2\u0083\u0084")
        buf.write("\t\4\2\2\u0084\u0085\5\36\20\2\u0085\u0087\3\2\2\2\u0086")
        buf.write("z\3\2\2\2\u0086~\3\2\2\2\u0086\u0082\3\2\2\2\u0087\35")
        buf.write("\3\2\2\2\u0088\u0089\b\20\1\2\u0089\u008a\7\27\2\2\u008a")
        buf.write("\u008b\5\36\20\2\u008b\u008c\7\30\2\2\u008c\u00a1\3\2")
        buf.write("\2\2\u008d\u0095\7\33\2\2\u008e\u0092\5\36\20\2\u008f")
        buf.write("\u0091\5\36\20\2\u0090\u008f\3\2\2\2\u0091\u0094\3\2\2")
        buf.write("\2\u0092\u0090\3\2\2\2\u0092\u0093\3\2\2\2\u0093\u0096")
        buf.write("\3\2\2\2\u0094\u0092\3\2\2\2\u0095\u008e\3\2\2\2\u0095")
        buf.write("\u0096\3\2\2\2\u0096\u0097\3\2\2\2\u0097\u00a1\7\34\2")
        buf.write("\2\u0098\u0099\7\37\2\2\u0099\u009a\7\31\2\2\u009a\u009b")
        buf.write("\t\5\2\2\u009b\u00a1\7\32\2\2\u009c\u00a1\7\"\2\2\u009d")
        buf.write("\u00a1\7\37\2\2\u009e\u00a1\7 \2\2\u009f\u00a1\7!\2\2")
        buf.write("\u00a0\u0088\3\2\2\2\u00a0\u008d\3\2\2\2\u00a0\u0098\3")
        buf.write("\2\2\2\u00a0\u009c\3\2\2\2\u00a0\u009d\3\2\2\2\u00a0\u009e")
        buf.write("\3\2\2\2\u00a0\u009f\3\2\2\2\u00a1\u00ad\3\2\2\2\u00a2")
        buf.write("\u00a3\f\f\2\2\u00a3\u00a4\t\6\2\2\u00a4\u00ac\5\36\20")
        buf.write("\r\u00a5\u00a6\f\13\2\2\u00a6\u00a7\t\7\2\2\u00a7\u00ac")
        buf.write("\5\36\20\f\u00a8\u00a9\f\n\2\2\u00a9\u00aa\7\20\2\2\u00aa")
        buf.write("\u00ac\5\36\20\13\u00ab\u00a2\3\2\2\2\u00ab\u00a5\3\2")
        buf.write("\2\2\u00ab\u00a8\3\2\2\2\u00ac\u00af\3\2\2\2\u00ad\u00ab")
        buf.write("\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ae\37\3\2\2\2\u00af\u00ad")
        buf.write("\3\2\2\2\20#-\609ES^k\u0086\u0092\u0095\u00a0\u00ab\u00ad")
        return buf.getvalue()


class jsbachParser ( Parser ):

    grammarFileName = "jsbach.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'<-'", "'<?>'", "'<!>'", "'<:>'", "'if'", 
                     "'else'", "'while'", "'<<'", "'8<'", "'+'", "'-'", 
                     "'*'", "'/'", "'%'", "'=='", "'/='", "'<'", "'<='", 
                     "'>'", "'>='", "'('", "')'", "'['", "']'", "'{'", "'}'", 
                     "'|:'", "':|'" ]

    symbolicNames = [ "<INVALID>", "ASSIGN", "READ", "WRITE", "PLAY", "IF", 
                      "ELSE", "WHILE", "ADD", "CUT", "PLUS", "MINUS", "MULT", 
                      "DIV", "MOD", "EQ", "NEQ", "LT", "LET", "GT", "GET", 
                      "LP", "RP", "LB", "RB", "LCB", "RCB", "OB", "CB", 
                      "VAR", "NUM", "STRING", "NOTE", "PROCNAME", "COMMENT", 
                      "WS" ]

    RULE_root = 0
    RULE_defProc = 1
    RULE_cjtInstr = 2
    RULE_instr = 3
    RULE_assign = 4
    RULE_read = 5
    RULE_write = 6
    RULE_play = 7
    RULE_invProc = 8
    RULE_conditional = 9
    RULE_while_ = 10
    RULE_addList = 11
    RULE_cutList = 12
    RULE_exprCond = 13
    RULE_expr = 14

    ruleNames =  [ "root", "defProc", "cjtInstr", "instr", "assign", "read", 
                   "write", "play", "invProc", "conditional", "while_", 
                   "addList", "cutList", "exprCond", "expr" ]

    EOF = Token.EOF
    ASSIGN=1
    READ=2
    WRITE=3
    PLAY=4
    IF=5
    ELSE=6
    WHILE=7
    ADD=8
    CUT=9
    PLUS=10
    MINUS=11
    MULT=12
    DIV=13
    MOD=14
    EQ=15
    NEQ=16
    LT=17
    LET=18
    GT=19
    GET=20
    LP=21
    RP=22
    LB=23
    RB=24
    LCB=25
    RCB=26
    OB=27
    CB=28
    VAR=29
    NUM=30
    STRING=31
    NOTE=32
    PROCNAME=33
    COMMENT=34
    WS=35

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class RootContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(jsbachParser.EOF, 0)

        def defProc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jsbachParser.DefProcContext)
            else:
                return self.getTypedRuleContext(jsbachParser.DefProcContext,i)


        def getRuleIndex(self):
            return jsbachParser.RULE_root

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoot" ):
                return visitor.visitRoot(self)
            else:
                return visitor.visitChildren(self)




    def root(self):

        localctx = jsbachParser.RootContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_root)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 33
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==jsbachParser.PROCNAME:
                self.state = 30
                self.defProc()
                self.state = 35
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 36
            self.match(jsbachParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefProcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCNAME(self):
            return self.getToken(jsbachParser.PROCNAME, 0)

        def OB(self):
            return self.getToken(jsbachParser.OB, 0)

        def cjtInstr(self):
            return self.getTypedRuleContext(jsbachParser.CjtInstrContext,0)


        def CB(self):
            return self.getToken(jsbachParser.CB, 0)

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(jsbachParser.VAR)
            else:
                return self.getToken(jsbachParser.VAR, i)

        def getRuleIndex(self):
            return jsbachParser.RULE_defProc

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefProc" ):
                return visitor.visitDefProc(self)
            else:
                return visitor.visitChildren(self)




    def defProc(self):

        localctx = jsbachParser.DefProcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_defProc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 38
            self.match(jsbachParser.PROCNAME)
            self.state = 46
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==jsbachParser.VAR:
                self.state = 39
                self.match(jsbachParser.VAR)
                self.state = 43
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==jsbachParser.VAR:
                    self.state = 40
                    self.match(jsbachParser.VAR)
                    self.state = 45
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 48
            self.match(jsbachParser.OB)
            self.state = 49
            self.cjtInstr()
            self.state = 50
            self.match(jsbachParser.CB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CjtInstrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def instr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jsbachParser.InstrContext)
            else:
                return self.getTypedRuleContext(jsbachParser.InstrContext,i)


        def getRuleIndex(self):
            return jsbachParser.RULE_cjtInstr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCjtInstr" ):
                return visitor.visitCjtInstr(self)
            else:
                return visitor.visitChildren(self)




    def cjtInstr(self):

        localctx = jsbachParser.CjtInstrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_cjtInstr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 55
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << jsbachParser.READ) | (1 << jsbachParser.WRITE) | (1 << jsbachParser.PLAY) | (1 << jsbachParser.IF) | (1 << jsbachParser.WHILE) | (1 << jsbachParser.CUT) | (1 << jsbachParser.VAR) | (1 << jsbachParser.PROCNAME))) != 0):
                self.state = 52
                self.instr()
                self.state = 57
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InstrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assign(self):
            return self.getTypedRuleContext(jsbachParser.AssignContext,0)


        def read(self):
            return self.getTypedRuleContext(jsbachParser.ReadContext,0)


        def write(self):
            return self.getTypedRuleContext(jsbachParser.WriteContext,0)


        def play(self):
            return self.getTypedRuleContext(jsbachParser.PlayContext,0)


        def invProc(self):
            return self.getTypedRuleContext(jsbachParser.InvProcContext,0)


        def conditional(self):
            return self.getTypedRuleContext(jsbachParser.ConditionalContext,0)


        def while_(self):
            return self.getTypedRuleContext(jsbachParser.While_Context,0)


        def addList(self):
            return self.getTypedRuleContext(jsbachParser.AddListContext,0)


        def cutList(self):
            return self.getTypedRuleContext(jsbachParser.CutListContext,0)


        def getRuleIndex(self):
            return jsbachParser.RULE_instr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstr" ):
                return visitor.visitInstr(self)
            else:
                return visitor.visitChildren(self)




    def instr(self):

        localctx = jsbachParser.InstrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_instr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 58
                self.assign()
                pass

            elif la_ == 2:
                self.state = 59
                self.read()
                pass

            elif la_ == 3:
                self.state = 60
                self.write()
                pass

            elif la_ == 4:
                self.state = 61
                self.play()
                pass

            elif la_ == 5:
                self.state = 62
                self.invProc()
                pass

            elif la_ == 6:
                self.state = 63
                self.conditional()
                pass

            elif la_ == 7:
                self.state = 64
                self.while_()
                pass

            elif la_ == 8:
                self.state = 65
                self.addList()
                pass

            elif la_ == 9:
                self.state = 66
                self.cutList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(jsbachParser.VAR, 0)

        def ASSIGN(self):
            return self.getToken(jsbachParser.ASSIGN, 0)

        def expr(self):
            return self.getTypedRuleContext(jsbachParser.ExprContext,0)


        def getRuleIndex(self):
            return jsbachParser.RULE_assign

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssign" ):
                return visitor.visitAssign(self)
            else:
                return visitor.visitChildren(self)




    def assign(self):

        localctx = jsbachParser.AssignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_assign)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.match(jsbachParser.VAR)
            self.state = 70
            self.match(jsbachParser.ASSIGN)
            self.state = 71
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def READ(self):
            return self.getToken(jsbachParser.READ, 0)

        def VAR(self):
            return self.getToken(jsbachParser.VAR, 0)

        def getRuleIndex(self):
            return jsbachParser.RULE_read

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRead" ):
                return visitor.visitRead(self)
            else:
                return visitor.visitChildren(self)




    def read(self):

        localctx = jsbachParser.ReadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_read)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 73
            self.match(jsbachParser.READ)
            self.state = 74
            self.match(jsbachParser.VAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WriteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WRITE(self):
            return self.getToken(jsbachParser.WRITE, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jsbachParser.ExprContext)
            else:
                return self.getTypedRuleContext(jsbachParser.ExprContext,i)


        def getRuleIndex(self):
            return jsbachParser.RULE_write

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWrite" ):
                return visitor.visitWrite(self)
            else:
                return visitor.visitChildren(self)




    def write(self):

        localctx = jsbachParser.WriteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_write)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 76
            self.match(jsbachParser.WRITE)
            self.state = 77
            self.expr(0)
            self.state = 81
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 78
                    self.expr(0) 
                self.state = 83
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PlayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLAY(self):
            return self.getToken(jsbachParser.PLAY, 0)

        def expr(self):
            return self.getTypedRuleContext(jsbachParser.ExprContext,0)


        def getRuleIndex(self):
            return jsbachParser.RULE_play

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlay" ):
                return visitor.visitPlay(self)
            else:
                return visitor.visitChildren(self)




    def play(self):

        localctx = jsbachParser.PlayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_play)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self.match(jsbachParser.PLAY)
            self.state = 85
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InvProcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROCNAME(self):
            return self.getToken(jsbachParser.PROCNAME, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jsbachParser.ExprContext)
            else:
                return self.getTypedRuleContext(jsbachParser.ExprContext,i)


        def getRuleIndex(self):
            return jsbachParser.RULE_invProc

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInvProc" ):
                return visitor.visitInvProc(self)
            else:
                return visitor.visitChildren(self)




    def invProc(self):

        localctx = jsbachParser.InvProcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_invProc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 87
            self.match(jsbachParser.PROCNAME)

            self.state = 88
            self.expr(0)
            self.state = 92
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 89
                    self.expr(0) 
                self.state = 94
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConditionalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(jsbachParser.IF, 0)

        def exprCond(self):
            return self.getTypedRuleContext(jsbachParser.ExprCondContext,0)


        def OB(self, i:int=None):
            if i is None:
                return self.getTokens(jsbachParser.OB)
            else:
                return self.getToken(jsbachParser.OB, i)

        def cjtInstr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jsbachParser.CjtInstrContext)
            else:
                return self.getTypedRuleContext(jsbachParser.CjtInstrContext,i)


        def CB(self, i:int=None):
            if i is None:
                return self.getTokens(jsbachParser.CB)
            else:
                return self.getToken(jsbachParser.CB, i)

        def ELSE(self):
            return self.getToken(jsbachParser.ELSE, 0)

        def getRuleIndex(self):
            return jsbachParser.RULE_conditional

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditional" ):
                return visitor.visitConditional(self)
            else:
                return visitor.visitChildren(self)




    def conditional(self):

        localctx = jsbachParser.ConditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_conditional)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self.match(jsbachParser.IF)
            self.state = 96
            self.exprCond()
            self.state = 97
            self.match(jsbachParser.OB)
            self.state = 98
            self.cjtInstr()
            self.state = 99
            self.match(jsbachParser.CB)
            self.state = 105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==jsbachParser.ELSE:
                self.state = 100
                self.match(jsbachParser.ELSE)
                self.state = 101
                self.match(jsbachParser.OB)
                self.state = 102
                self.cjtInstr()
                self.state = 103
                self.match(jsbachParser.CB)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class While_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(jsbachParser.WHILE, 0)

        def exprCond(self):
            return self.getTypedRuleContext(jsbachParser.ExprCondContext,0)


        def OB(self):
            return self.getToken(jsbachParser.OB, 0)

        def cjtInstr(self):
            return self.getTypedRuleContext(jsbachParser.CjtInstrContext,0)


        def CB(self):
            return self.getToken(jsbachParser.CB, 0)

        def getRuleIndex(self):
            return jsbachParser.RULE_while_

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhile_" ):
                return visitor.visitWhile_(self)
            else:
                return visitor.visitChildren(self)




    def while_(self):

        localctx = jsbachParser.While_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_while_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self.match(jsbachParser.WHILE)
            self.state = 108
            self.exprCond()
            self.state = 109
            self.match(jsbachParser.OB)
            self.state = 110
            self.cjtInstr()
            self.state = 111
            self.match(jsbachParser.CB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AddListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(jsbachParser.VAR, 0)

        def ADD(self):
            return self.getToken(jsbachParser.ADD, 0)

        def expr(self):
            return self.getTypedRuleContext(jsbachParser.ExprContext,0)


        def getRuleIndex(self):
            return jsbachParser.RULE_addList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddList" ):
                return visitor.visitAddList(self)
            else:
                return visitor.visitChildren(self)




    def addList(self):

        localctx = jsbachParser.AddListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_addList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.match(jsbachParser.VAR)
            self.state = 114
            self.match(jsbachParser.ADD)
            self.state = 115
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CutListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CUT(self):
            return self.getToken(jsbachParser.CUT, 0)

        def expr(self):
            return self.getTypedRuleContext(jsbachParser.ExprContext,0)


        def getRuleIndex(self):
            return jsbachParser.RULE_cutList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCutList" ):
                return visitor.visitCutList(self)
            else:
                return visitor.visitChildren(self)




    def cutList(self):

        localctx = jsbachParser.CutListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_cutList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.match(jsbachParser.CUT)
            self.state = 118
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprCondContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return jsbachParser.RULE_exprCond

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class CondContext(ExprCondContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a jsbachParser.ExprCondContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.op = None # Token
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jsbachParser.ExprContext)
            else:
                return self.getTypedRuleContext(jsbachParser.ExprContext,i)

        def EQ(self):
            return self.getToken(jsbachParser.EQ, 0)
        def NEQ(self):
            return self.getToken(jsbachParser.NEQ, 0)
        def LT(self):
            return self.getToken(jsbachParser.LT, 0)
        def LET(self):
            return self.getToken(jsbachParser.LET, 0)
        def GT(self):
            return self.getToken(jsbachParser.GT, 0)
        def GET(self):
            return self.getToken(jsbachParser.GET, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond" ):
                return visitor.visitCond(self)
            else:
                return visitor.visitChildren(self)



    def exprCond(self):

        localctx = jsbachParser.ExprCondContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_exprCond)
        self._la = 0 # Token type
        try:
            self.state = 132
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                localctx = jsbachParser.CondContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 120
                localctx.left = self.expr(0)
                self.state = 121
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==jsbachParser.EQ or _la==jsbachParser.NEQ):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 122
                localctx.right = self.expr(0)
                pass

            elif la_ == 2:
                localctx = jsbachParser.CondContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 124
                localctx.left = self.expr(0)
                self.state = 125
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==jsbachParser.LT or _la==jsbachParser.LET):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 126
                localctx.right = self.expr(0)
                pass

            elif la_ == 3:
                localctx = jsbachParser.CondContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 128
                localctx.left = self.expr(0)
                self.state = 129
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==jsbachParser.GT or _la==jsbachParser.GET):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 130
                localctx.right = self.expr(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return jsbachParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class VariablesContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a jsbachParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAR(self):
            return self.getToken(jsbachParser.VAR, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariables" ):
                return visitor.visitVariables(self)
            else:
                return visitor.visitChildren(self)


    class NumbersContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a jsbachParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUM(self):
            return self.getToken(jsbachParser.NUM, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumbers" ):
                return visitor.visitNumbers(self)
            else:
                return visitor.visitChildren(self)


    class NoteContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a jsbachParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOTE(self):
            return self.getToken(jsbachParser.NOTE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNote" ):
                return visitor.visitNote(self)
            else:
                return visitor.visitChildren(self)


    class ListElementContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a jsbachParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(jsbachParser.VAR)
            else:
                return self.getToken(jsbachParser.VAR, i)
        def LB(self):
            return self.getToken(jsbachParser.LB, 0)
        def RB(self):
            return self.getToken(jsbachParser.RB, 0)
        def NUM(self):
            return self.getToken(jsbachParser.NUM, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListElement" ):
                return visitor.visitListElement(self)
            else:
                return visitor.visitChildren(self)


    class ListContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a jsbachParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LCB(self):
            return self.getToken(jsbachParser.LCB, 0)
        def RCB(self):
            return self.getToken(jsbachParser.RCB, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jsbachParser.ExprContext)
            else:
                return self.getTypedRuleContext(jsbachParser.ExprContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitList" ):
                return visitor.visitList(self)
            else:
                return visitor.visitChildren(self)


    class InfixOpContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a jsbachParser.ExprContext
            super().__init__(parser)
            self.left = None # ExprContext
            self.op = None # Token
            self.right = None # ExprContext
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jsbachParser.ExprContext)
            else:
                return self.getTypedRuleContext(jsbachParser.ExprContext,i)

        def MULT(self):
            return self.getToken(jsbachParser.MULT, 0)
        def DIV(self):
            return self.getToken(jsbachParser.DIV, 0)
        def PLUS(self):
            return self.getToken(jsbachParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(jsbachParser.MINUS, 0)
        def MOD(self):
            return self.getToken(jsbachParser.MOD, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInfixOp" ):
                return visitor.visitInfixOp(self)
            else:
                return visitor.visitChildren(self)


    class StringsContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a jsbachParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(jsbachParser.STRING, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStrings" ):
                return visitor.visitStrings(self)
            else:
                return visitor.visitChildren(self)


    class ParenContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a jsbachParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LP(self):
            return self.getToken(jsbachParser.LP, 0)
        def expr(self):
            return self.getTypedRuleContext(jsbachParser.ExprContext,0)

        def RP(self):
            return self.getToken(jsbachParser.RP, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParen" ):
                return visitor.visitParen(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = jsbachParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 28
        self.enterRecursionRule(localctx, 28, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                localctx = jsbachParser.ParenContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 135
                self.match(jsbachParser.LP)
                self.state = 136
                self.expr(0)
                self.state = 137
                self.match(jsbachParser.RP)
                pass

            elif la_ == 2:
                localctx = jsbachParser.ListContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 139
                self.match(jsbachParser.LCB)
                self.state = 147
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << jsbachParser.LP) | (1 << jsbachParser.LCB) | (1 << jsbachParser.VAR) | (1 << jsbachParser.NUM) | (1 << jsbachParser.STRING) | (1 << jsbachParser.NOTE))) != 0):
                    self.state = 140
                    self.expr(0)
                    self.state = 144
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << jsbachParser.LP) | (1 << jsbachParser.LCB) | (1 << jsbachParser.VAR) | (1 << jsbachParser.NUM) | (1 << jsbachParser.STRING) | (1 << jsbachParser.NOTE))) != 0):
                        self.state = 141
                        self.expr(0)
                        self.state = 146
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 149
                self.match(jsbachParser.RCB)
                pass

            elif la_ == 3:
                localctx = jsbachParser.ListElementContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 150
                self.match(jsbachParser.VAR)
                self.state = 151
                self.match(jsbachParser.LB)
                self.state = 152
                _la = self._input.LA(1)
                if not(_la==jsbachParser.VAR or _la==jsbachParser.NUM):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 153
                self.match(jsbachParser.RB)
                pass

            elif la_ == 4:
                localctx = jsbachParser.NoteContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 154
                self.match(jsbachParser.NOTE)
                pass

            elif la_ == 5:
                localctx = jsbachParser.VariablesContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 155
                self.match(jsbachParser.VAR)
                pass

            elif la_ == 6:
                localctx = jsbachParser.NumbersContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 156
                self.match(jsbachParser.NUM)
                pass

            elif la_ == 7:
                localctx = jsbachParser.StringsContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 157
                self.match(jsbachParser.STRING)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 171
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,13,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 169
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
                    if la_ == 1:
                        localctx = jsbachParser.InfixOpContext(self, jsbachParser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 160
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 161
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==jsbachParser.MULT or _la==jsbachParser.DIV):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 162
                        localctx.right = self.expr(11)
                        pass

                    elif la_ == 2:
                        localctx = jsbachParser.InfixOpContext(self, jsbachParser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 163
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 164
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==jsbachParser.PLUS or _la==jsbachParser.MINUS):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 165
                        localctx.right = self.expr(10)
                        pass

                    elif la_ == 3:
                        localctx = jsbachParser.InfixOpContext(self, jsbachParser.ExprContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 166
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 167
                        localctx.op = self.match(jsbachParser.MOD)
                        self.state = 168
                        localctx.right = self.expr(9)
                        pass

             
                self.state = 173
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[14] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 8)
         




